var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"data_ratios\ndata_profile\nperformance_profile\nperformance_ratios\nBenchmarkProfiles.performance_profile_data","category":"page"},{"location":"reference/#BenchmarkProfiles.data_ratios","page":"Reference","title":"BenchmarkProfiles.data_ratios","text":"Compute data ratios used to produce a data profile.\n\nThere is normally no need to call this function directly. See the documentation of data_profile() for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BenchmarkProfiles.data_profile","page":"Reference","title":"BenchmarkProfiles.data_profile","text":"Produce a data profile.\n\nThe 3-dimensional array H gives the performance data for each solver and each problem (smaller is better). H[k,p,s] is the k-th costly operation (e.g., function evaluation) for problem p and solver s. Failures on a given problem are represented by a negative value, an infinite value, or NaN.\n\nThe vector N gives a scaling associated to each problem. If the number of simplex gradients is being measured, N[p] should be n(p) + 1 where n(p) is the number of variables of problem p.\n\nThe threshold τ determines the tolerance in the convergence criterion\n\nf(x) ≤ fL + τ (f0 - fL),\n\nwhere for each problem f(x) is a measure recorded (e.g., the objective value), f0 is the measure at the initial point, and fL is the best measure obtained by any solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BenchmarkProfiles.performance_profile","page":"Reference","title":"BenchmarkProfiles.performance_profile","text":"Produce a performance profile.\n\nEach column of the matrix T defines the performance data for a solver (smaller is better). Failures on a given problem are represented by a negative value, an infinite value, or NaN. The optional argument logscale is used to produce a logarithmic (base 2) performance plot.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BenchmarkProfiles.performance_ratios","page":"Reference","title":"BenchmarkProfiles.performance_ratios","text":"Compute performance ratios used to produce a performance profile.\n\nThere is normally no need to call this function directly. See the documentation of performance_profile() for more information.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BenchmarkProfiles.performance_profile_data","page":"Reference","title":"BenchmarkProfiles.performance_profile_data","text":"Produce the coordinates for a performance profile.\n\nThere is normally no need to call this function directly. See the documentation of performance_profile() for more information.\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"BenchmarkProfiles.jl documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A simple package to plot performance and data profiles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package containts Julia translations of original scripts by Elizabeth Dolan, Jorge Moré and Stefan Wild. See http://www.mcs.anl.gov/~wild/dfo/benchmarking.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The original code was not accompanied by an open-source license. Jorge Moré and Stefan Wild have kindly provided their consent in writing to allow distribution of this Julia translation. See here for a full transcription.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Watch out for the pitfalls of profiles!","category":"page"},{"location":"#How-to-Install","page":"Home","title":"How to Install","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add BenchmarkProfiles","category":"page"},{"location":"","page":"Home","title":"Home","text":"Plotting in handled by Plots.jl so the user can choose among several available plotting backends.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> using BenchmarkProfiles\njulia> T = 10 * rand(25, 3) # 25 problems, 3 solvers\njulia> performance_profile(T, [\"Solver 1\", \"Solver 2\", \"Solver 3\"], title=\"Celebrity Deathmatch\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Performance Profile)","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"E. Dolan and J. Moré, Benchmarking Optimization Software with Performance Profiles, Mathematical Programming 91, pages 201–213, 2002. DOI 10.1007/s101070100263.","category":"page"},{"location":"","page":"Home","title":"Home","text":"J. J. Moré and S. M. Wild, Benchmarking Derivative-Free Optimization Algorithms, SIAM Journal on Optimization, 20(1), pages 172–191, 2009. DOI 10.1137/080724083.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This tutorial is essentially a collection of examples.","category":"page"},{"location":"tutorial/#Performance-Profile","page":"Tutorial","title":"Performance Profile","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Performance profiles are straightforward to use. The input is a matrix T with entries T[i,j] indicating the cost to solve problem i using solver j. Cost can be, for instance, elapsed time, or number of evaluations. The cost should be positive. If any cost is zero, all measures will be shifted by 1.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Basic usage:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using BenchmarkProfiles, Random\n\nRandom.seed!(0)\n\nT = 10 * rand(25, 3)\nperformance_profile(T, [\"Solver 1\", \"Solver 2\", \"Solver 3\"])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A negative or infinite cost indicates a failure:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"T[2:20,1] .= Inf\nperformance_profile(T, [\"Solver 1\", \"Solver 2\", \"Solver 3\"])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here's an example with a strongly superior solver.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"T[:,2] = 100T[:,3]\nperformance_profile(T, [\"Solver 1\", \"Solver 2\", \"Solver 3\"])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Plots arguments can be passed to performance_profile() or used as they normally would be with Plots. In the example below, we pass xlabel to performance_profile and set ylabel through ylabel!.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\n\nT = 10 * rand(25, 3)\nperformance_profile(T, [\"Solver 1\", \"Solver 2\", \"Solver 3\"],\n      lw=2, c=:black, linestyles=[:solid, :dash, :dot], xlabel=\"\\\\tau\")\nylabel!(\"\\\\rho(\\\\tau)\")","category":"page"}]
}
